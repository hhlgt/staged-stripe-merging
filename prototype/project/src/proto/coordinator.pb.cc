// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coordinator.proto

#include "coordinator.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace coordinator_proto {
PROTOBUF_CONSTEXPR Parameter::Parameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.partial_decoding_)*/false
  , /*decltype(_impl_.encodetype_)*/0
  , /*decltype(_impl_.s_stripe_placementtype_)*/0
  , /*decltype(_impl_.m_stripe_placementtype_)*/0
  , /*decltype(_impl_.k_datablock_)*/0
  , /*decltype(_impl_.l_localparityblock_)*/0
  , /*decltype(_impl_.g_m_globalparityblock_)*/0
  , /*decltype(_impl_.b_datapergroup_)*/0
  , /*decltype(_impl_.x_stripepermergegroup_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterDefaultTypeInternal() {}
  union {
    Parameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterDefaultTypeInternal _Parameter_default_instance_;
PROTOBUF_CONSTEXPR RepIfSetParaSuccess::RepIfSetParaSuccess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifsetparameter_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepIfSetParaSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepIfSetParaSuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepIfSetParaSuccessDefaultTypeInternal() {}
  union {
    RepIfSetParaSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepIfSetParaSuccessDefaultTypeInternal _RepIfSetParaSuccess_default_instance_;
PROTOBUF_CONSTEXPR RequestToCoordinator::RequestToCoordinator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestToCoordinatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestToCoordinatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestToCoordinatorDefaultTypeInternal() {}
  union {
    RequestToCoordinator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestToCoordinatorDefaultTypeInternal _RequestToCoordinator_default_instance_;
PROTOBUF_CONSTEXPR ReplyFromCoordinator::ReplyFromCoordinator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReplyFromCoordinatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplyFromCoordinatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplyFromCoordinatorDefaultTypeInternal() {}
  union {
    ReplyFromCoordinator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplyFromCoordinatorDefaultTypeInternal _ReplyFromCoordinator_default_instance_;
PROTOBUF_CONSTEXPR RequestProxyIPPort::RequestProxyIPPort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.valuesizebytes_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestProxyIPPortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestProxyIPPortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestProxyIPPortDefaultTypeInternal() {}
  union {
    RequestProxyIPPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestProxyIPPortDefaultTypeInternal _RequestProxyIPPort_default_instance_;
PROTOBUF_CONSTEXPR ReplyProxyIPPort::ReplyProxyIPPort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proxyip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.proxyport_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReplyProxyIPPortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplyProxyIPPortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplyProxyIPPortDefaultTypeInternal() {}
  union {
    ReplyProxyIPPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplyProxyIPPortDefaultTypeInternal _ReplyProxyIPPort_default_instance_;
PROTOBUF_CONSTEXPR CommitAbortKey::CommitAbortKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ifcommitmetadata_)*/false
  , /*decltype(_impl_.opp_)*/0
  , /*decltype(_impl_.stripe_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CommitAbortKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitAbortKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitAbortKeyDefaultTypeInternal() {}
  union {
    CommitAbortKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitAbortKeyDefaultTypeInternal _CommitAbortKey_default_instance_;
PROTOBUF_CONSTEXPR AskIfSuccess::AskIfSuccess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.opp_)*/0
  , /*decltype(_impl_.stripe_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AskIfSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AskIfSuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AskIfSuccessDefaultTypeInternal() {}
  union {
    AskIfSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AskIfSuccessDefaultTypeInternal _AskIfSuccess_default_instance_;
PROTOBUF_CONSTEXPR RepIfSuccess::RepIfSuccess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifcommit_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepIfSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepIfSuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepIfSuccessDefaultTypeInternal() {}
  union {
    RepIfSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepIfSuccessDefaultTypeInternal _RepIfSuccess_default_instance_;
PROTOBUF_CONSTEXPR KeyAndClientIP::KeyAndClientIP(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clientip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clientport_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyAndClientIPDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyAndClientIPDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyAndClientIPDefaultTypeInternal() {}
  union {
    KeyAndClientIP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyAndClientIPDefaultTypeInternal _KeyAndClientIP_default_instance_;
PROTOBUF_CONSTEXPR RepIfGetSuccess::RepIfGetSuccess(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifgetsuccess_)*/false
  , /*decltype(_impl_.valuesizebytes_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepIfGetSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepIfGetSuccessDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepIfGetSuccessDefaultTypeInternal() {}
  union {
    RepIfGetSuccess _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepIfGetSuccessDefaultTypeInternal _RepIfGetSuccess_default_instance_;
PROTOBUF_CONSTEXPR KeyFromClient::KeyFromClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KeyFromClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyFromClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyFromClientDefaultTypeInternal() {}
  union {
    KeyFromClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyFromClientDefaultTypeInternal _KeyFromClient_default_instance_;
PROTOBUF_CONSTEXPR StripeIdFromClient::StripeIdFromClient(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stripe_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StripeIdFromClientDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StripeIdFromClientDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StripeIdFromClientDefaultTypeInternal() {}
  union {
    StripeIdFromClient _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StripeIdFromClientDefaultTypeInternal _StripeIdFromClient_default_instance_;
PROTOBUF_CONSTEXPR RepIfDeling::RepIfDeling(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifdeling_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepIfDelingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepIfDelingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepIfDelingDefaultTypeInternal() {}
  union {
    RepIfDeling _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepIfDelingDefaultTypeInternal _RepIfDeling_default_instance_;
PROTOBUF_CONSTEXPR NumberOfStripesToMerge::NumberOfStripesToMerge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_of_stripes_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NumberOfStripesToMergeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NumberOfStripesToMergeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NumberOfStripesToMergeDefaultTypeInternal() {}
  union {
    NumberOfStripesToMerge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NumberOfStripesToMergeDefaultTypeInternal _NumberOfStripesToMerge_default_instance_;
PROTOBUF_CONSTEXPR RepIfMerged::RepIfMerged(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lc_)*/0
  , /*decltype(_impl_.gc_)*/0
  , /*decltype(_impl_.dc_)*/0
  , /*decltype(_impl_.ifmerged_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepIfMergedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepIfMergedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepIfMergedDefaultTypeInternal() {}
  union {
    RepIfMerged _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepIfMergedDefaultTypeInternal _RepIfMerged_default_instance_;
PROTOBUF_CONSTEXPR RepStripeIds::RepStripeIds(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stripe_ids_)*/{}
  , /*decltype(_impl_._stripe_ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepStripeIdsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepStripeIdsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepStripeIdsDefaultTypeInternal() {}
  union {
    RepStripeIds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepStripeIdsDefaultTypeInternal _RepStripeIds_default_instance_;
}  // namespace coordinator_proto
static ::_pb::Metadata file_level_metadata_coordinator_2eproto[17];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_coordinator_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_coordinator_2eproto = nullptr;

const uint32_t TableStruct_coordinator_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.partial_decoding_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.encodetype_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.s_stripe_placementtype_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.m_stripe_placementtype_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.k_datablock_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.l_localparityblock_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.g_m_globalparityblock_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.b_datapergroup_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::Parameter, _impl_.x_stripepermergegroup_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfSetParaSuccess, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfSetParaSuccess, _impl_.ifsetparameter_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RequestToCoordinator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RequestToCoordinator, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::ReplyFromCoordinator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::ReplyFromCoordinator, _impl_.message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RequestProxyIPPort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RequestProxyIPPort, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RequestProxyIPPort, _impl_.valuesizebytes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::ReplyProxyIPPort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::ReplyProxyIPPort, _impl_.proxyip_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::ReplyProxyIPPort, _impl_.proxyport_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::CommitAbortKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::CommitAbortKey, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::CommitAbortKey, _impl_.ifcommitmetadata_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::CommitAbortKey, _impl_.opp_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::CommitAbortKey, _impl_.stripe_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::AskIfSuccess, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::AskIfSuccess, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::AskIfSuccess, _impl_.opp_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::AskIfSuccess, _impl_.stripe_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfSuccess, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfSuccess, _impl_.ifcommit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyAndClientIP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyAndClientIP, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyAndClientIP, _impl_.clientip_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyAndClientIP, _impl_.clientport_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfGetSuccess, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfGetSuccess, _impl_.ifgetsuccess_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfGetSuccess, _impl_.valuesizebytes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyFromClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::KeyFromClient, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::StripeIdFromClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::StripeIdFromClient, _impl_.stripe_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfDeling, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfDeling, _impl_.ifdeling_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::NumberOfStripesToMerge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::NumberOfStripesToMerge, _impl_.num_of_stripes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfMerged, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfMerged, _impl_.ifmerged_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfMerged, _impl_.lc_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfMerged, _impl_.gc_),
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepIfMerged, _impl_.dc_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepStripeIds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::coordinator_proto::RepStripeIds, _impl_.stripe_ids_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::coordinator_proto::Parameter)},
  { 15, -1, -1, sizeof(::coordinator_proto::RepIfSetParaSuccess)},
  { 22, -1, -1, sizeof(::coordinator_proto::RequestToCoordinator)},
  { 29, -1, -1, sizeof(::coordinator_proto::ReplyFromCoordinator)},
  { 36, -1, -1, sizeof(::coordinator_proto::RequestProxyIPPort)},
  { 44, -1, -1, sizeof(::coordinator_proto::ReplyProxyIPPort)},
  { 52, -1, -1, sizeof(::coordinator_proto::CommitAbortKey)},
  { 62, -1, -1, sizeof(::coordinator_proto::AskIfSuccess)},
  { 71, -1, -1, sizeof(::coordinator_proto::RepIfSuccess)},
  { 78, -1, -1, sizeof(::coordinator_proto::KeyAndClientIP)},
  { 87, -1, -1, sizeof(::coordinator_proto::RepIfGetSuccess)},
  { 95, -1, -1, sizeof(::coordinator_proto::KeyFromClient)},
  { 102, -1, -1, sizeof(::coordinator_proto::StripeIdFromClient)},
  { 109, -1, -1, sizeof(::coordinator_proto::RepIfDeling)},
  { 116, -1, -1, sizeof(::coordinator_proto::NumberOfStripesToMerge)},
  { 123, -1, -1, sizeof(::coordinator_proto::RepIfMerged)},
  { 133, -1, -1, sizeof(::coordinator_proto::RepStripeIds)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::coordinator_proto::_Parameter_default_instance_._instance,
  &::coordinator_proto::_RepIfSetParaSuccess_default_instance_._instance,
  &::coordinator_proto::_RequestToCoordinator_default_instance_._instance,
  &::coordinator_proto::_ReplyFromCoordinator_default_instance_._instance,
  &::coordinator_proto::_RequestProxyIPPort_default_instance_._instance,
  &::coordinator_proto::_ReplyProxyIPPort_default_instance_._instance,
  &::coordinator_proto::_CommitAbortKey_default_instance_._instance,
  &::coordinator_proto::_AskIfSuccess_default_instance_._instance,
  &::coordinator_proto::_RepIfSuccess_default_instance_._instance,
  &::coordinator_proto::_KeyAndClientIP_default_instance_._instance,
  &::coordinator_proto::_RepIfGetSuccess_default_instance_._instance,
  &::coordinator_proto::_KeyFromClient_default_instance_._instance,
  &::coordinator_proto::_StripeIdFromClient_default_instance_._instance,
  &::coordinator_proto::_RepIfDeling_default_instance_._instance,
  &::coordinator_proto::_NumberOfStripesToMerge_default_instance_._instance,
  &::coordinator_proto::_RepIfMerged_default_instance_._instance,
  &::coordinator_proto::_RepStripeIds_default_instance_._instance,
};

const char descriptor_table_protodef_coordinator_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021coordinator.proto\022\021coordinator_proto\"\200"
  "\002\n\tParameter\022\030\n\020partial_decoding\030\001 \001(\010\022\022"
  "\n\nencodetype\030\002 \001(\005\022\036\n\026s_stripe_placement"
  "type\030\003 \001(\005\022\036\n\026m_stripe_placementtype\030\004 \001"
  "(\005\022\023\n\013k_datablock\030\005 \001(\005\022\032\n\022l_localparity"
  "block\030\006 \001(\005\022\035\n\025g_m_globalparityblock\030\007 \001"
  "(\005\022\026\n\016b_datapergroup\030\010 \001(\005\022\035\n\025x_stripepe"
  "rmergegroup\030\t \001(\005\"-\n\023RepIfSetParaSuccess"
  "\022\026\n\016ifsetparameter\030\001 \001(\010\"$\n\024RequestToCoo"
  "rdinator\022\014\n\004name\030\001 \001(\t\"\'\n\024ReplyFromCoord"
  "inator\022\017\n\007message\030\001 \001(\t\"9\n\022RequestProxyI"
  "PPort\022\013\n\003key\030\001 \001(\t\022\026\n\016valuesizebytes\030\002 \001"
  "(\005\"6\n\020ReplyProxyIPPort\022\017\n\007proxyip\030\001 \001(\t\022"
  "\021\n\tproxyport\030\002 \001(\005\"W\n\016CommitAbortKey\022\013\n\003"
  "key\030\001 \001(\t\022\030\n\020ifcommitmetadata\030\002 \001(\010\022\013\n\003o"
  "pp\030\003 \001(\005\022\021\n\tstripe_id\030\004 \001(\005\";\n\014AskIfSucc"
  "ess\022\013\n\003key\030\001 \001(\t\022\013\n\003opp\030\002 \001(\005\022\021\n\tstripe_"
  "id\030\003 \001(\005\" \n\014RepIfSuccess\022\020\n\010ifcommit\030\001 \001"
  "(\010\"C\n\016KeyAndClientIP\022\013\n\003key\030\001 \001(\t\022\020\n\010cli"
  "entip\030\002 \001(\t\022\022\n\nclientport\030\003 \001(\005\"\?\n\017RepIf"
  "GetSuccess\022\024\n\014ifgetsuccess\030\001 \001(\010\022\026\n\016valu"
  "esizebytes\030\002 \001(\005\"\034\n\rKeyFromClient\022\013\n\003key"
  "\030\001 \001(\t\"\'\n\022StripeIdFromClient\022\021\n\tstripe_i"
  "d\030\001 \001(\005\"\037\n\013RepIfDeling\022\020\n\010ifdeling\030\001 \001(\010"
  "\"0\n\026NumberOfStripesToMerge\022\026\n\016num_of_str"
  "ipes\030\001 \001(\005\"C\n\013RepIfMerged\022\020\n\010ifmerged\030\001 "
  "\001(\010\022\n\n\002lc\030\002 \001(\001\022\n\n\002gc\030\003 \001(\001\022\n\n\002dc\030\004 \001(\001\""
  "\"\n\014RepStripeIds\022\022\n\nstripe_ids\030\001 \003(\0052\221\010\n\022"
  "coordinatorService\022k\n\025sayHelloToCoordina"
  "tor\022\'.coordinator_proto.RequestToCoordin"
  "ator\032\'.coordinator_proto.ReplyFromCoordi"
  "nator\"\000\022`\n\ncheckalive\022\'.coordinator_prot"
  "o.RequestToCoordinator\032\'.coordinator_pro"
  "to.ReplyFromCoordinator\"\000\022V\n\014setParamete"
  "r\022\034.coordinator_proto.Parameter\032&.coordi"
  "nator_proto.RepIfSetParaSuccess\"\000\022d\n\024upl"
  "oadOriginKeyValue\022%.coordinator_proto.Re"
  "questProxyIPPort\032#.coordinator_proto.Rep"
  "lyProxyIPPort\"\000\022a\n\021reportCommitAbort\022!.c"
  "oordinator_proto.CommitAbortKey\032\'.coordi"
  "nator_proto.ReplyFromCoordinator\"\000\022V\n\020ch"
  "eckCommitAbort\022\037.coordinator_proto.AskIf"
  "Success\032\037.coordinator_proto.RepIfSuccess"
  "\"\000\022S\n\010getValue\022!.coordinator_proto.KeyAn"
  "dClientIP\032\".coordinator_proto.RepIfGetSu"
  "ccess\"\000\022N\n\010delByKey\022 .coordinator_proto."
  "KeyFromClient\032\036.coordinator_proto.RepIfD"
  "eling\"\000\022V\n\013delByStripe\022%.coordinator_pro"
  "to.StripeIdFromClient\032\036.coordinator_prot"
  "o.RepIfDeling\"\000\022[\n\014requestMerge\022).coordi"
  "nator_proto.NumberOfStripesToMerge\032\036.coo"
  "rdinator_proto.RepIfMerged\"\000\022Y\n\013listStri"
  "pes\022\'.coordinator_proto.RequestToCoordin"
  "ator\032\037.coordinator_proto.RepStripeIds\"\000b"
  "\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_coordinator_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_coordinator_2eproto = {
    false, false, 2167, descriptor_table_protodef_coordinator_2eproto,
    "coordinator.proto",
    &descriptor_table_coordinator_2eproto_once, nullptr, 0, 17,
    schemas, file_default_instances, TableStruct_coordinator_2eproto::offsets,
    file_level_metadata_coordinator_2eproto, file_level_enum_descriptors_coordinator_2eproto,
    file_level_service_descriptors_coordinator_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_coordinator_2eproto_getter() {
  return &descriptor_table_coordinator_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_coordinator_2eproto(&descriptor_table_coordinator_2eproto);
namespace coordinator_proto {

// ===================================================================

class Parameter::_Internal {
 public:
};

Parameter::Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.Parameter)
}
Parameter::Parameter(const Parameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Parameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.partial_decoding_){}
    , decltype(_impl_.encodetype_){}
    , decltype(_impl_.s_stripe_placementtype_){}
    , decltype(_impl_.m_stripe_placementtype_){}
    , decltype(_impl_.k_datablock_){}
    , decltype(_impl_.l_localparityblock_){}
    , decltype(_impl_.g_m_globalparityblock_){}
    , decltype(_impl_.b_datapergroup_){}
    , decltype(_impl_.x_stripepermergegroup_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.partial_decoding_, &from._impl_.partial_decoding_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.x_stripepermergegroup_) -
    reinterpret_cast<char*>(&_impl_.partial_decoding_)) + sizeof(_impl_.x_stripepermergegroup_));
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.Parameter)
}

inline void Parameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.partial_decoding_){false}
    , decltype(_impl_.encodetype_){0}
    , decltype(_impl_.s_stripe_placementtype_){0}
    , decltype(_impl_.m_stripe_placementtype_){0}
    , decltype(_impl_.k_datablock_){0}
    , decltype(_impl_.l_localparityblock_){0}
    , decltype(_impl_.g_m_globalparityblock_){0}
    , decltype(_impl_.b_datapergroup_){0}
    , decltype(_impl_.x_stripepermergegroup_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Parameter::~Parameter() {
  // @@protoc_insertion_point(destructor:coordinator_proto.Parameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Parameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Parameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Parameter::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.Parameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.partial_decoding_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.x_stripepermergegroup_) -
      reinterpret_cast<char*>(&_impl_.partial_decoding_)) + sizeof(_impl_.x_stripepermergegroup_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Parameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool partial_decoding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.partial_decoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 encodetype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.encodetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 s_stripe_placementtype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.s_stripe_placementtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 m_stripe_placementtype = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.m_stripe_placementtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 k_datablock = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.k_datablock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 l_localparityblock = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.l_localparityblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 g_m_globalparityblock = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.g_m_globalparityblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 b_datapergroup = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.b_datapergroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 x_stripepermergegroup = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.x_stripepermergegroup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Parameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.Parameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool partial_decoding = 1;
  if (this->_internal_partial_decoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_partial_decoding(), target);
  }

  // int32 encodetype = 2;
  if (this->_internal_encodetype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_encodetype(), target);
  }

  // int32 s_stripe_placementtype = 3;
  if (this->_internal_s_stripe_placementtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_s_stripe_placementtype(), target);
  }

  // int32 m_stripe_placementtype = 4;
  if (this->_internal_m_stripe_placementtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_m_stripe_placementtype(), target);
  }

  // int32 k_datablock = 5;
  if (this->_internal_k_datablock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_k_datablock(), target);
  }

  // int32 l_localparityblock = 6;
  if (this->_internal_l_localparityblock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_l_localparityblock(), target);
  }

  // int32 g_m_globalparityblock = 7;
  if (this->_internal_g_m_globalparityblock() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_g_m_globalparityblock(), target);
  }

  // int32 b_datapergroup = 8;
  if (this->_internal_b_datapergroup() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_b_datapergroup(), target);
  }

  // int32 x_stripepermergegroup = 9;
  if (this->_internal_x_stripepermergegroup() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_x_stripepermergegroup(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.Parameter)
  return target;
}

size_t Parameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.Parameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool partial_decoding = 1;
  if (this->_internal_partial_decoding() != 0) {
    total_size += 1 + 1;
  }

  // int32 encodetype = 2;
  if (this->_internal_encodetype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_encodetype());
  }

  // int32 s_stripe_placementtype = 3;
  if (this->_internal_s_stripe_placementtype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_s_stripe_placementtype());
  }

  // int32 m_stripe_placementtype = 4;
  if (this->_internal_m_stripe_placementtype() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_stripe_placementtype());
  }

  // int32 k_datablock = 5;
  if (this->_internal_k_datablock() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_k_datablock());
  }

  // int32 l_localparityblock = 6;
  if (this->_internal_l_localparityblock() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_l_localparityblock());
  }

  // int32 g_m_globalparityblock = 7;
  if (this->_internal_g_m_globalparityblock() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_g_m_globalparityblock());
  }

  // int32 b_datapergroup = 8;
  if (this->_internal_b_datapergroup() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_b_datapergroup());
  }

  // int32 x_stripepermergegroup = 9;
  if (this->_internal_x_stripepermergegroup() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x_stripepermergegroup());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Parameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Parameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Parameter::GetClassData() const { return &_class_data_; }


void Parameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Parameter*>(&to_msg);
  auto& from = static_cast<const Parameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.Parameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_partial_decoding() != 0) {
    _this->_internal_set_partial_decoding(from._internal_partial_decoding());
  }
  if (from._internal_encodetype() != 0) {
    _this->_internal_set_encodetype(from._internal_encodetype());
  }
  if (from._internal_s_stripe_placementtype() != 0) {
    _this->_internal_set_s_stripe_placementtype(from._internal_s_stripe_placementtype());
  }
  if (from._internal_m_stripe_placementtype() != 0) {
    _this->_internal_set_m_stripe_placementtype(from._internal_m_stripe_placementtype());
  }
  if (from._internal_k_datablock() != 0) {
    _this->_internal_set_k_datablock(from._internal_k_datablock());
  }
  if (from._internal_l_localparityblock() != 0) {
    _this->_internal_set_l_localparityblock(from._internal_l_localparityblock());
  }
  if (from._internal_g_m_globalparityblock() != 0) {
    _this->_internal_set_g_m_globalparityblock(from._internal_g_m_globalparityblock());
  }
  if (from._internal_b_datapergroup() != 0) {
    _this->_internal_set_b_datapergroup(from._internal_b_datapergroup());
  }
  if (from._internal_x_stripepermergegroup() != 0) {
    _this->_internal_set_x_stripepermergegroup(from._internal_x_stripepermergegroup());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Parameter::CopyFrom(const Parameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.Parameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameter::IsInitialized() const {
  return true;
}

void Parameter::InternalSwap(Parameter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Parameter, _impl_.x_stripepermergegroup_)
      + sizeof(Parameter::_impl_.x_stripepermergegroup_)
      - PROTOBUF_FIELD_OFFSET(Parameter, _impl_.partial_decoding_)>(
          reinterpret_cast<char*>(&_impl_.partial_decoding_),
          reinterpret_cast<char*>(&other->_impl_.partial_decoding_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Parameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[0]);
}

// ===================================================================

class RepIfSetParaSuccess::_Internal {
 public:
};

RepIfSetParaSuccess::RepIfSetParaSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepIfSetParaSuccess)
}
RepIfSetParaSuccess::RepIfSetParaSuccess(const RepIfSetParaSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepIfSetParaSuccess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifsetparameter_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ifsetparameter_ = from._impl_.ifsetparameter_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepIfSetParaSuccess)
}

inline void RepIfSetParaSuccess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifsetparameter_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepIfSetParaSuccess::~RepIfSetParaSuccess() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepIfSetParaSuccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepIfSetParaSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepIfSetParaSuccess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepIfSetParaSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepIfSetParaSuccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ifsetparameter_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepIfSetParaSuccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ifsetparameter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifsetparameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepIfSetParaSuccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepIfSetParaSuccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ifsetparameter = 1;
  if (this->_internal_ifsetparameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifsetparameter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepIfSetParaSuccess)
  return target;
}

size_t RepIfSetParaSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepIfSetParaSuccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ifsetparameter = 1;
  if (this->_internal_ifsetparameter() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepIfSetParaSuccess::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepIfSetParaSuccess::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepIfSetParaSuccess::GetClassData() const { return &_class_data_; }


void RepIfSetParaSuccess::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepIfSetParaSuccess*>(&to_msg);
  auto& from = static_cast<const RepIfSetParaSuccess&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepIfSetParaSuccess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ifsetparameter() != 0) {
    _this->_internal_set_ifsetparameter(from._internal_ifsetparameter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepIfSetParaSuccess::CopyFrom(const RepIfSetParaSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepIfSetParaSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepIfSetParaSuccess::IsInitialized() const {
  return true;
}

void RepIfSetParaSuccess::InternalSwap(RepIfSetParaSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ifsetparameter_, other->_impl_.ifsetparameter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RepIfSetParaSuccess::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[1]);
}

// ===================================================================

class RequestToCoordinator::_Internal {
 public:
};

RequestToCoordinator::RequestToCoordinator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RequestToCoordinator)
}
RequestToCoordinator::RequestToCoordinator(const RequestToCoordinator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestToCoordinator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RequestToCoordinator)
}

inline void RequestToCoordinator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestToCoordinator::~RequestToCoordinator() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RequestToCoordinator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestToCoordinator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void RequestToCoordinator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestToCoordinator::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RequestToCoordinator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestToCoordinator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.RequestToCoordinator.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestToCoordinator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RequestToCoordinator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.RequestToCoordinator.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RequestToCoordinator)
  return target;
}

size_t RequestToCoordinator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RequestToCoordinator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestToCoordinator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestToCoordinator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestToCoordinator::GetClassData() const { return &_class_data_; }


void RequestToCoordinator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestToCoordinator*>(&to_msg);
  auto& from = static_cast<const RequestToCoordinator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RequestToCoordinator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestToCoordinator::CopyFrom(const RequestToCoordinator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RequestToCoordinator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestToCoordinator::IsInitialized() const {
  return true;
}

void RequestToCoordinator::InternalSwap(RequestToCoordinator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestToCoordinator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[2]);
}

// ===================================================================

class ReplyFromCoordinator::_Internal {
 public:
};

ReplyFromCoordinator::ReplyFromCoordinator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.ReplyFromCoordinator)
}
ReplyFromCoordinator::ReplyFromCoordinator(const ReplyFromCoordinator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplyFromCoordinator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.ReplyFromCoordinator)
}

inline void ReplyFromCoordinator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplyFromCoordinator::~ReplyFromCoordinator() {
  // @@protoc_insertion_point(destructor:coordinator_proto.ReplyFromCoordinator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplyFromCoordinator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void ReplyFromCoordinator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplyFromCoordinator::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.ReplyFromCoordinator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplyFromCoordinator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.ReplyFromCoordinator.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplyFromCoordinator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.ReplyFromCoordinator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.ReplyFromCoordinator.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.ReplyFromCoordinator)
  return target;
}

size_t ReplyFromCoordinator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.ReplyFromCoordinator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplyFromCoordinator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplyFromCoordinator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplyFromCoordinator::GetClassData() const { return &_class_data_; }


void ReplyFromCoordinator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplyFromCoordinator*>(&to_msg);
  auto& from = static_cast<const ReplyFromCoordinator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.ReplyFromCoordinator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplyFromCoordinator::CopyFrom(const ReplyFromCoordinator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.ReplyFromCoordinator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplyFromCoordinator::IsInitialized() const {
  return true;
}

void ReplyFromCoordinator::InternalSwap(ReplyFromCoordinator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplyFromCoordinator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[3]);
}

// ===================================================================

class RequestProxyIPPort::_Internal {
 public:
};

RequestProxyIPPort::RequestProxyIPPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RequestProxyIPPort)
}
RequestProxyIPPort::RequestProxyIPPort(const RequestProxyIPPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestProxyIPPort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.valuesizebytes_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.valuesizebytes_ = from._impl_.valuesizebytes_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RequestProxyIPPort)
}

inline void RequestProxyIPPort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.valuesizebytes_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestProxyIPPort::~RequestProxyIPPort() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RequestProxyIPPort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestProxyIPPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void RequestProxyIPPort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestProxyIPPort::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RequestProxyIPPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.valuesizebytes_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestProxyIPPort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.RequestProxyIPPort.key"));
        } else
          goto handle_unusual;
        continue;
      // int32 valuesizebytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.valuesizebytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestProxyIPPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RequestProxyIPPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.RequestProxyIPPort.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // int32 valuesizebytes = 2;
  if (this->_internal_valuesizebytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_valuesizebytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RequestProxyIPPort)
  return target;
}

size_t RequestProxyIPPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RequestProxyIPPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // int32 valuesizebytes = 2;
  if (this->_internal_valuesizebytes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_valuesizebytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestProxyIPPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestProxyIPPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestProxyIPPort::GetClassData() const { return &_class_data_; }


void RequestProxyIPPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestProxyIPPort*>(&to_msg);
  auto& from = static_cast<const RequestProxyIPPort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RequestProxyIPPort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_valuesizebytes() != 0) {
    _this->_internal_set_valuesizebytes(from._internal_valuesizebytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestProxyIPPort::CopyFrom(const RequestProxyIPPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RequestProxyIPPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestProxyIPPort::IsInitialized() const {
  return true;
}

void RequestProxyIPPort::InternalSwap(RequestProxyIPPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.valuesizebytes_, other->_impl_.valuesizebytes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestProxyIPPort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[4]);
}

// ===================================================================

class ReplyProxyIPPort::_Internal {
 public:
};

ReplyProxyIPPort::ReplyProxyIPPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.ReplyProxyIPPort)
}
ReplyProxyIPPort::ReplyProxyIPPort(const ReplyProxyIPPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplyProxyIPPort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proxyip_){}
    , decltype(_impl_.proxyport_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.proxyip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proxyip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_proxyip().empty()) {
    _this->_impl_.proxyip_.Set(from._internal_proxyip(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.proxyport_ = from._impl_.proxyport_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.ReplyProxyIPPort)
}

inline void ReplyProxyIPPort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proxyip_){}
    , decltype(_impl_.proxyport_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.proxyip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.proxyip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplyProxyIPPort::~ReplyProxyIPPort() {
  // @@protoc_insertion_point(destructor:coordinator_proto.ReplyProxyIPPort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplyProxyIPPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.proxyip_.Destroy();
}

void ReplyProxyIPPort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplyProxyIPPort::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.ReplyProxyIPPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.proxyip_.ClearToEmpty();
  _impl_.proxyport_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplyProxyIPPort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string proxyip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_proxyip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.ReplyProxyIPPort.proxyip"));
        } else
          goto handle_unusual;
        continue;
      // int32 proxyport = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.proxyport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplyProxyIPPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.ReplyProxyIPPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string proxyip = 1;
  if (!this->_internal_proxyip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_proxyip().data(), static_cast<int>(this->_internal_proxyip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.ReplyProxyIPPort.proxyip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_proxyip(), target);
  }

  // int32 proxyport = 2;
  if (this->_internal_proxyport() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_proxyport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.ReplyProxyIPPort)
  return target;
}

size_t ReplyProxyIPPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.ReplyProxyIPPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string proxyip = 1;
  if (!this->_internal_proxyip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_proxyip());
  }

  // int32 proxyport = 2;
  if (this->_internal_proxyport() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_proxyport());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplyProxyIPPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplyProxyIPPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplyProxyIPPort::GetClassData() const { return &_class_data_; }


void ReplyProxyIPPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplyProxyIPPort*>(&to_msg);
  auto& from = static_cast<const ReplyProxyIPPort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.ReplyProxyIPPort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_proxyip().empty()) {
    _this->_internal_set_proxyip(from._internal_proxyip());
  }
  if (from._internal_proxyport() != 0) {
    _this->_internal_set_proxyport(from._internal_proxyport());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplyProxyIPPort::CopyFrom(const ReplyProxyIPPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.ReplyProxyIPPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplyProxyIPPort::IsInitialized() const {
  return true;
}

void ReplyProxyIPPort::InternalSwap(ReplyProxyIPPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.proxyip_, lhs_arena,
      &other->_impl_.proxyip_, rhs_arena
  );
  swap(_impl_.proxyport_, other->_impl_.proxyport_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplyProxyIPPort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[5]);
}

// ===================================================================

class CommitAbortKey::_Internal {
 public:
};

CommitAbortKey::CommitAbortKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.CommitAbortKey)
}
CommitAbortKey::CommitAbortKey(const CommitAbortKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommitAbortKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.ifcommitmetadata_){}
    , decltype(_impl_.opp_){}
    , decltype(_impl_.stripe_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ifcommitmetadata_, &from._impl_.ifcommitmetadata_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stripe_id_) -
    reinterpret_cast<char*>(&_impl_.ifcommitmetadata_)) + sizeof(_impl_.stripe_id_));
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.CommitAbortKey)
}

inline void CommitAbortKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.ifcommitmetadata_){false}
    , decltype(_impl_.opp_){0}
    , decltype(_impl_.stripe_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommitAbortKey::~CommitAbortKey() {
  // @@protoc_insertion_point(destructor:coordinator_proto.CommitAbortKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitAbortKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void CommitAbortKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommitAbortKey::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.CommitAbortKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  ::memset(&_impl_.ifcommitmetadata_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.stripe_id_) -
      reinterpret_cast<char*>(&_impl_.ifcommitmetadata_)) + sizeof(_impl_.stripe_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommitAbortKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.CommitAbortKey.key"));
        } else
          goto handle_unusual;
        continue;
      // bool ifcommitmetadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ifcommitmetadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 opp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.opp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 stripe_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.stripe_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommitAbortKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.CommitAbortKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.CommitAbortKey.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // bool ifcommitmetadata = 2;
  if (this->_internal_ifcommitmetadata() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_ifcommitmetadata(), target);
  }

  // int32 opp = 3;
  if (this->_internal_opp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_opp(), target);
  }

  // int32 stripe_id = 4;
  if (this->_internal_stripe_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_stripe_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.CommitAbortKey)
  return target;
}

size_t CommitAbortKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.CommitAbortKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // bool ifcommitmetadata = 2;
  if (this->_internal_ifcommitmetadata() != 0) {
    total_size += 1 + 1;
  }

  // int32 opp = 3;
  if (this->_internal_opp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_opp());
  }

  // int32 stripe_id = 4;
  if (this->_internal_stripe_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stripe_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommitAbortKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommitAbortKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommitAbortKey::GetClassData() const { return &_class_data_; }


void CommitAbortKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommitAbortKey*>(&to_msg);
  auto& from = static_cast<const CommitAbortKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.CommitAbortKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_ifcommitmetadata() != 0) {
    _this->_internal_set_ifcommitmetadata(from._internal_ifcommitmetadata());
  }
  if (from._internal_opp() != 0) {
    _this->_internal_set_opp(from._internal_opp());
  }
  if (from._internal_stripe_id() != 0) {
    _this->_internal_set_stripe_id(from._internal_stripe_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommitAbortKey::CopyFrom(const CommitAbortKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.CommitAbortKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitAbortKey::IsInitialized() const {
  return true;
}

void CommitAbortKey::InternalSwap(CommitAbortKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommitAbortKey, _impl_.stripe_id_)
      + sizeof(CommitAbortKey::_impl_.stripe_id_)
      - PROTOBUF_FIELD_OFFSET(CommitAbortKey, _impl_.ifcommitmetadata_)>(
          reinterpret_cast<char*>(&_impl_.ifcommitmetadata_),
          reinterpret_cast<char*>(&other->_impl_.ifcommitmetadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommitAbortKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[6]);
}

// ===================================================================

class AskIfSuccess::_Internal {
 public:
};

AskIfSuccess::AskIfSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.AskIfSuccess)
}
AskIfSuccess::AskIfSuccess(const AskIfSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AskIfSuccess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.opp_){}
    , decltype(_impl_.stripe_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.opp_, &from._impl_.opp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stripe_id_) -
    reinterpret_cast<char*>(&_impl_.opp_)) + sizeof(_impl_.stripe_id_));
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.AskIfSuccess)
}

inline void AskIfSuccess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.opp_){0}
    , decltype(_impl_.stripe_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AskIfSuccess::~AskIfSuccess() {
  // @@protoc_insertion_point(destructor:coordinator_proto.AskIfSuccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AskIfSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void AskIfSuccess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AskIfSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.AskIfSuccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  ::memset(&_impl_.opp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.stripe_id_) -
      reinterpret_cast<char*>(&_impl_.opp_)) + sizeof(_impl_.stripe_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AskIfSuccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.AskIfSuccess.key"));
        } else
          goto handle_unusual;
        continue;
      // int32 opp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.opp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 stripe_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.stripe_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AskIfSuccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.AskIfSuccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.AskIfSuccess.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // int32 opp = 2;
  if (this->_internal_opp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_opp(), target);
  }

  // int32 stripe_id = 3;
  if (this->_internal_stripe_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_stripe_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.AskIfSuccess)
  return target;
}

size_t AskIfSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.AskIfSuccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // int32 opp = 2;
  if (this->_internal_opp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_opp());
  }

  // int32 stripe_id = 3;
  if (this->_internal_stripe_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stripe_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AskIfSuccess::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AskIfSuccess::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AskIfSuccess::GetClassData() const { return &_class_data_; }


void AskIfSuccess::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AskIfSuccess*>(&to_msg);
  auto& from = static_cast<const AskIfSuccess&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.AskIfSuccess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_opp() != 0) {
    _this->_internal_set_opp(from._internal_opp());
  }
  if (from._internal_stripe_id() != 0) {
    _this->_internal_set_stripe_id(from._internal_stripe_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AskIfSuccess::CopyFrom(const AskIfSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.AskIfSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AskIfSuccess::IsInitialized() const {
  return true;
}

void AskIfSuccess::InternalSwap(AskIfSuccess* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AskIfSuccess, _impl_.stripe_id_)
      + sizeof(AskIfSuccess::_impl_.stripe_id_)
      - PROTOBUF_FIELD_OFFSET(AskIfSuccess, _impl_.opp_)>(
          reinterpret_cast<char*>(&_impl_.opp_),
          reinterpret_cast<char*>(&other->_impl_.opp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AskIfSuccess::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[7]);
}

// ===================================================================

class RepIfSuccess::_Internal {
 public:
};

RepIfSuccess::RepIfSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepIfSuccess)
}
RepIfSuccess::RepIfSuccess(const RepIfSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepIfSuccess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifcommit_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ifcommit_ = from._impl_.ifcommit_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepIfSuccess)
}

inline void RepIfSuccess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifcommit_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepIfSuccess::~RepIfSuccess() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepIfSuccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepIfSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepIfSuccess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepIfSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepIfSuccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ifcommit_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepIfSuccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ifcommit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifcommit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepIfSuccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepIfSuccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ifcommit = 1;
  if (this->_internal_ifcommit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifcommit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepIfSuccess)
  return target;
}

size_t RepIfSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepIfSuccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ifcommit = 1;
  if (this->_internal_ifcommit() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepIfSuccess::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepIfSuccess::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepIfSuccess::GetClassData() const { return &_class_data_; }


void RepIfSuccess::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepIfSuccess*>(&to_msg);
  auto& from = static_cast<const RepIfSuccess&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepIfSuccess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ifcommit() != 0) {
    _this->_internal_set_ifcommit(from._internal_ifcommit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepIfSuccess::CopyFrom(const RepIfSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepIfSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepIfSuccess::IsInitialized() const {
  return true;
}

void RepIfSuccess::InternalSwap(RepIfSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ifcommit_, other->_impl_.ifcommit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RepIfSuccess::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[8]);
}

// ===================================================================

class KeyAndClientIP::_Internal {
 public:
};

KeyAndClientIP::KeyAndClientIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.KeyAndClientIP)
}
KeyAndClientIP::KeyAndClientIP(const KeyAndClientIP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyAndClientIP* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.clientip_){}
    , decltype(_impl_.clientport_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.clientip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_clientip().empty()) {
    _this->_impl_.clientip_.Set(from._internal_clientip(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.clientport_ = from._impl_.clientport_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.KeyAndClientIP)
}

inline void KeyAndClientIP::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.clientip_){}
    , decltype(_impl_.clientport_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clientip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clientip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyAndClientIP::~KeyAndClientIP() {
  // @@protoc_insertion_point(destructor:coordinator_proto.KeyAndClientIP)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyAndClientIP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.clientip_.Destroy();
}

void KeyAndClientIP::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyAndClientIP::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.KeyAndClientIP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.clientip_.ClearToEmpty();
  _impl_.clientport_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyAndClientIP::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.KeyAndClientIP.key"));
        } else
          goto handle_unusual;
        continue;
      // string clientip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_clientip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.KeyAndClientIP.clientip"));
        } else
          goto handle_unusual;
        continue;
      // int32 clientport = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.clientport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyAndClientIP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.KeyAndClientIP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.KeyAndClientIP.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string clientip = 2;
  if (!this->_internal_clientip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_clientip().data(), static_cast<int>(this->_internal_clientip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.KeyAndClientIP.clientip");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_clientip(), target);
  }

  // int32 clientport = 3;
  if (this->_internal_clientport() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_clientport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.KeyAndClientIP)
  return target;
}

size_t KeyAndClientIP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.KeyAndClientIP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string clientip = 2;
  if (!this->_internal_clientip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_clientip());
  }

  // int32 clientport = 3;
  if (this->_internal_clientport() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_clientport());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyAndClientIP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyAndClientIP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyAndClientIP::GetClassData() const { return &_class_data_; }


void KeyAndClientIP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyAndClientIP*>(&to_msg);
  auto& from = static_cast<const KeyAndClientIP&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.KeyAndClientIP)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_clientip().empty()) {
    _this->_internal_set_clientip(from._internal_clientip());
  }
  if (from._internal_clientport() != 0) {
    _this->_internal_set_clientport(from._internal_clientport());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyAndClientIP::CopyFrom(const KeyAndClientIP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.KeyAndClientIP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyAndClientIP::IsInitialized() const {
  return true;
}

void KeyAndClientIP::InternalSwap(KeyAndClientIP* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clientip_, lhs_arena,
      &other->_impl_.clientip_, rhs_arena
  );
  swap(_impl_.clientport_, other->_impl_.clientport_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyAndClientIP::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[9]);
}

// ===================================================================

class RepIfGetSuccess::_Internal {
 public:
};

RepIfGetSuccess::RepIfGetSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepIfGetSuccess)
}
RepIfGetSuccess::RepIfGetSuccess(const RepIfGetSuccess& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepIfGetSuccess* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifgetsuccess_){}
    , decltype(_impl_.valuesizebytes_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ifgetsuccess_, &from._impl_.ifgetsuccess_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valuesizebytes_) -
    reinterpret_cast<char*>(&_impl_.ifgetsuccess_)) + sizeof(_impl_.valuesizebytes_));
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepIfGetSuccess)
}

inline void RepIfGetSuccess::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifgetsuccess_){false}
    , decltype(_impl_.valuesizebytes_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepIfGetSuccess::~RepIfGetSuccess() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepIfGetSuccess)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepIfGetSuccess::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepIfGetSuccess::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepIfGetSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepIfGetSuccess)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.ifgetsuccess_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.valuesizebytes_) -
      reinterpret_cast<char*>(&_impl_.ifgetsuccess_)) + sizeof(_impl_.valuesizebytes_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepIfGetSuccess::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ifgetsuccess = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifgetsuccess_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 valuesizebytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.valuesizebytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepIfGetSuccess::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepIfGetSuccess)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ifgetsuccess = 1;
  if (this->_internal_ifgetsuccess() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifgetsuccess(), target);
  }

  // int32 valuesizebytes = 2;
  if (this->_internal_valuesizebytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_valuesizebytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepIfGetSuccess)
  return target;
}

size_t RepIfGetSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepIfGetSuccess)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ifgetsuccess = 1;
  if (this->_internal_ifgetsuccess() != 0) {
    total_size += 1 + 1;
  }

  // int32 valuesizebytes = 2;
  if (this->_internal_valuesizebytes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_valuesizebytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepIfGetSuccess::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepIfGetSuccess::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepIfGetSuccess::GetClassData() const { return &_class_data_; }


void RepIfGetSuccess::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepIfGetSuccess*>(&to_msg);
  auto& from = static_cast<const RepIfGetSuccess&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepIfGetSuccess)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ifgetsuccess() != 0) {
    _this->_internal_set_ifgetsuccess(from._internal_ifgetsuccess());
  }
  if (from._internal_valuesizebytes() != 0) {
    _this->_internal_set_valuesizebytes(from._internal_valuesizebytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepIfGetSuccess::CopyFrom(const RepIfGetSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepIfGetSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepIfGetSuccess::IsInitialized() const {
  return true;
}

void RepIfGetSuccess::InternalSwap(RepIfGetSuccess* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepIfGetSuccess, _impl_.valuesizebytes_)
      + sizeof(RepIfGetSuccess::_impl_.valuesizebytes_)
      - PROTOBUF_FIELD_OFFSET(RepIfGetSuccess, _impl_.ifgetsuccess_)>(
          reinterpret_cast<char*>(&_impl_.ifgetsuccess_),
          reinterpret_cast<char*>(&other->_impl_.ifgetsuccess_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RepIfGetSuccess::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[10]);
}

// ===================================================================

class KeyFromClient::_Internal {
 public:
};

KeyFromClient::KeyFromClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.KeyFromClient)
}
KeyFromClient::KeyFromClient(const KeyFromClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyFromClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.KeyFromClient)
}

inline void KeyFromClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyFromClient::~KeyFromClient() {
  // @@protoc_insertion_point(destructor:coordinator_proto.KeyFromClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyFromClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void KeyFromClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyFromClient::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.KeyFromClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyFromClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "coordinator_proto.KeyFromClient.key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyFromClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.KeyFromClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "coordinator_proto.KeyFromClient.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.KeyFromClient)
  return target;
}

size_t KeyFromClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.KeyFromClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyFromClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyFromClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyFromClient::GetClassData() const { return &_class_data_; }


void KeyFromClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyFromClient*>(&to_msg);
  auto& from = static_cast<const KeyFromClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.KeyFromClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyFromClient::CopyFrom(const KeyFromClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.KeyFromClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyFromClient::IsInitialized() const {
  return true;
}

void KeyFromClient::InternalSwap(KeyFromClient* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyFromClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[11]);
}

// ===================================================================

class StripeIdFromClient::_Internal {
 public:
};

StripeIdFromClient::StripeIdFromClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.StripeIdFromClient)
}
StripeIdFromClient::StripeIdFromClient(const StripeIdFromClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StripeIdFromClient* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stripe_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.stripe_id_ = from._impl_.stripe_id_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.StripeIdFromClient)
}

inline void StripeIdFromClient::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stripe_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StripeIdFromClient::~StripeIdFromClient() {
  // @@protoc_insertion_point(destructor:coordinator_proto.StripeIdFromClient)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StripeIdFromClient::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StripeIdFromClient::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StripeIdFromClient::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.StripeIdFromClient)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stripe_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StripeIdFromClient::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 stripe_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.stripe_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StripeIdFromClient::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.StripeIdFromClient)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 stripe_id = 1;
  if (this->_internal_stripe_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_stripe_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.StripeIdFromClient)
  return target;
}

size_t StripeIdFromClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.StripeIdFromClient)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 stripe_id = 1;
  if (this->_internal_stripe_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stripe_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StripeIdFromClient::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StripeIdFromClient::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StripeIdFromClient::GetClassData() const { return &_class_data_; }


void StripeIdFromClient::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StripeIdFromClient*>(&to_msg);
  auto& from = static_cast<const StripeIdFromClient&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.StripeIdFromClient)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_stripe_id() != 0) {
    _this->_internal_set_stripe_id(from._internal_stripe_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StripeIdFromClient::CopyFrom(const StripeIdFromClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.StripeIdFromClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StripeIdFromClient::IsInitialized() const {
  return true;
}

void StripeIdFromClient::InternalSwap(StripeIdFromClient* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stripe_id_, other->_impl_.stripe_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StripeIdFromClient::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[12]);
}

// ===================================================================

class RepIfDeling::_Internal {
 public:
};

RepIfDeling::RepIfDeling(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepIfDeling)
}
RepIfDeling::RepIfDeling(const RepIfDeling& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepIfDeling* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifdeling_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.ifdeling_ = from._impl_.ifdeling_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepIfDeling)
}

inline void RepIfDeling::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifdeling_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepIfDeling::~RepIfDeling() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepIfDeling)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepIfDeling::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepIfDeling::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepIfDeling::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepIfDeling)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ifdeling_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepIfDeling::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ifdeling = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifdeling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepIfDeling::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepIfDeling)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ifdeling = 1;
  if (this->_internal_ifdeling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifdeling(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepIfDeling)
  return target;
}

size_t RepIfDeling::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepIfDeling)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool ifdeling = 1;
  if (this->_internal_ifdeling() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepIfDeling::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepIfDeling::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepIfDeling::GetClassData() const { return &_class_data_; }


void RepIfDeling::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepIfDeling*>(&to_msg);
  auto& from = static_cast<const RepIfDeling&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepIfDeling)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ifdeling() != 0) {
    _this->_internal_set_ifdeling(from._internal_ifdeling());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepIfDeling::CopyFrom(const RepIfDeling& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepIfDeling)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepIfDeling::IsInitialized() const {
  return true;
}

void RepIfDeling::InternalSwap(RepIfDeling* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ifdeling_, other->_impl_.ifdeling_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RepIfDeling::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[13]);
}

// ===================================================================

class NumberOfStripesToMerge::_Internal {
 public:
};

NumberOfStripesToMerge::NumberOfStripesToMerge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.NumberOfStripesToMerge)
}
NumberOfStripesToMerge::NumberOfStripesToMerge(const NumberOfStripesToMerge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NumberOfStripesToMerge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_of_stripes_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.num_of_stripes_ = from._impl_.num_of_stripes_;
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.NumberOfStripesToMerge)
}

inline void NumberOfStripesToMerge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_of_stripes_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NumberOfStripesToMerge::~NumberOfStripesToMerge() {
  // @@protoc_insertion_point(destructor:coordinator_proto.NumberOfStripesToMerge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NumberOfStripesToMerge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NumberOfStripesToMerge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NumberOfStripesToMerge::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.NumberOfStripesToMerge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_of_stripes_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NumberOfStripesToMerge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 num_of_stripes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_of_stripes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NumberOfStripesToMerge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.NumberOfStripesToMerge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 num_of_stripes = 1;
  if (this->_internal_num_of_stripes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_of_stripes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.NumberOfStripesToMerge)
  return target;
}

size_t NumberOfStripesToMerge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.NumberOfStripesToMerge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 num_of_stripes = 1;
  if (this->_internal_num_of_stripes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_of_stripes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NumberOfStripesToMerge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NumberOfStripesToMerge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NumberOfStripesToMerge::GetClassData() const { return &_class_data_; }


void NumberOfStripesToMerge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NumberOfStripesToMerge*>(&to_msg);
  auto& from = static_cast<const NumberOfStripesToMerge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.NumberOfStripesToMerge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num_of_stripes() != 0) {
    _this->_internal_set_num_of_stripes(from._internal_num_of_stripes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NumberOfStripesToMerge::CopyFrom(const NumberOfStripesToMerge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.NumberOfStripesToMerge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NumberOfStripesToMerge::IsInitialized() const {
  return true;
}

void NumberOfStripesToMerge::InternalSwap(NumberOfStripesToMerge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.num_of_stripes_, other->_impl_.num_of_stripes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NumberOfStripesToMerge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[14]);
}

// ===================================================================

class RepIfMerged::_Internal {
 public:
};

RepIfMerged::RepIfMerged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepIfMerged)
}
RepIfMerged::RepIfMerged(const RepIfMerged& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepIfMerged* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lc_){}
    , decltype(_impl_.gc_){}
    , decltype(_impl_.dc_){}
    , decltype(_impl_.ifmerged_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lc_, &from._impl_.lc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ifmerged_) -
    reinterpret_cast<char*>(&_impl_.lc_)) + sizeof(_impl_.ifmerged_));
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepIfMerged)
}

inline void RepIfMerged::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lc_){0}
    , decltype(_impl_.gc_){0}
    , decltype(_impl_.dc_){0}
    , decltype(_impl_.ifmerged_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepIfMerged::~RepIfMerged() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepIfMerged)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepIfMerged::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RepIfMerged::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepIfMerged::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepIfMerged)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.lc_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ifmerged_) -
      reinterpret_cast<char*>(&_impl_.lc_)) + sizeof(_impl_.ifmerged_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepIfMerged::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool ifmerged = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifmerged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double lc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.lc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double gc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.gc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double dc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.dc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepIfMerged::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepIfMerged)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool ifmerged = 1;
  if (this->_internal_ifmerged() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ifmerged(), target);
  }

  // double lc = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_lc = this->_internal_lc();
  uint64_t raw_lc;
  memcpy(&raw_lc, &tmp_lc, sizeof(tmp_lc));
  if (raw_lc != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_lc(), target);
  }

  // double gc = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gc = this->_internal_gc();
  uint64_t raw_gc;
  memcpy(&raw_gc, &tmp_gc, sizeof(tmp_gc));
  if (raw_gc != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_gc(), target);
  }

  // double dc = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dc = this->_internal_dc();
  uint64_t raw_dc;
  memcpy(&raw_dc, &tmp_dc, sizeof(tmp_dc));
  if (raw_dc != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_dc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepIfMerged)
  return target;
}

size_t RepIfMerged::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepIfMerged)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double lc = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_lc = this->_internal_lc();
  uint64_t raw_lc;
  memcpy(&raw_lc, &tmp_lc, sizeof(tmp_lc));
  if (raw_lc != 0) {
    total_size += 1 + 8;
  }

  // double gc = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gc = this->_internal_gc();
  uint64_t raw_gc;
  memcpy(&raw_gc, &tmp_gc, sizeof(tmp_gc));
  if (raw_gc != 0) {
    total_size += 1 + 8;
  }

  // double dc = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dc = this->_internal_dc();
  uint64_t raw_dc;
  memcpy(&raw_dc, &tmp_dc, sizeof(tmp_dc));
  if (raw_dc != 0) {
    total_size += 1 + 8;
  }

  // bool ifmerged = 1;
  if (this->_internal_ifmerged() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepIfMerged::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepIfMerged::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepIfMerged::GetClassData() const { return &_class_data_; }


void RepIfMerged::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepIfMerged*>(&to_msg);
  auto& from = static_cast<const RepIfMerged&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepIfMerged)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_lc = from._internal_lc();
  uint64_t raw_lc;
  memcpy(&raw_lc, &tmp_lc, sizeof(tmp_lc));
  if (raw_lc != 0) {
    _this->_internal_set_lc(from._internal_lc());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gc = from._internal_gc();
  uint64_t raw_gc;
  memcpy(&raw_gc, &tmp_gc, sizeof(tmp_gc));
  if (raw_gc != 0) {
    _this->_internal_set_gc(from._internal_gc());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_dc = from._internal_dc();
  uint64_t raw_dc;
  memcpy(&raw_dc, &tmp_dc, sizeof(tmp_dc));
  if (raw_dc != 0) {
    _this->_internal_set_dc(from._internal_dc());
  }
  if (from._internal_ifmerged() != 0) {
    _this->_internal_set_ifmerged(from._internal_ifmerged());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepIfMerged::CopyFrom(const RepIfMerged& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepIfMerged)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepIfMerged::IsInitialized() const {
  return true;
}

void RepIfMerged::InternalSwap(RepIfMerged* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepIfMerged, _impl_.ifmerged_)
      + sizeof(RepIfMerged::_impl_.ifmerged_)
      - PROTOBUF_FIELD_OFFSET(RepIfMerged, _impl_.lc_)>(
          reinterpret_cast<char*>(&_impl_.lc_),
          reinterpret_cast<char*>(&other->_impl_.lc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RepIfMerged::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[15]);
}

// ===================================================================

class RepStripeIds::_Internal {
 public:
};

RepStripeIds::RepStripeIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:coordinator_proto.RepStripeIds)
}
RepStripeIds::RepStripeIds(const RepStripeIds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepStripeIds* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stripe_ids_){from._impl_.stripe_ids_}
    , /*decltype(_impl_._stripe_ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:coordinator_proto.RepStripeIds)
}

inline void RepStripeIds::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stripe_ids_){arena}
    , /*decltype(_impl_._stripe_ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepStripeIds::~RepStripeIds() {
  // @@protoc_insertion_point(destructor:coordinator_proto.RepStripeIds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepStripeIds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stripe_ids_.~RepeatedField();
}

void RepStripeIds::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepStripeIds::Clear() {
// @@protoc_insertion_point(message_clear_start:coordinator_proto.RepStripeIds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stripe_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepStripeIds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 stripe_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_stripe_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_stripe_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepStripeIds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:coordinator_proto.RepStripeIds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 stripe_ids = 1;
  {
    int byte_size = _impl_._stripe_ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_stripe_ids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:coordinator_proto.RepStripeIds)
  return target;
}

size_t RepStripeIds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:coordinator_proto.RepStripeIds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 stripe_ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.stripe_ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._stripe_ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepStripeIds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepStripeIds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepStripeIds::GetClassData() const { return &_class_data_; }


void RepStripeIds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepStripeIds*>(&to_msg);
  auto& from = static_cast<const RepStripeIds&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:coordinator_proto.RepStripeIds)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stripe_ids_.MergeFrom(from._impl_.stripe_ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepStripeIds::CopyFrom(const RepStripeIds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:coordinator_proto.RepStripeIds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepStripeIds::IsInitialized() const {
  return true;
}

void RepStripeIds::InternalSwap(RepStripeIds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stripe_ids_.InternalSwap(&other->_impl_.stripe_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RepStripeIds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_coordinator_2eproto_getter, &descriptor_table_coordinator_2eproto_once,
      file_level_metadata_coordinator_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace coordinator_proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::coordinator_proto::Parameter*
Arena::CreateMaybeMessage< ::coordinator_proto::Parameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::Parameter >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepIfSetParaSuccess*
Arena::CreateMaybeMessage< ::coordinator_proto::RepIfSetParaSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepIfSetParaSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RequestToCoordinator*
Arena::CreateMaybeMessage< ::coordinator_proto::RequestToCoordinator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RequestToCoordinator >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::ReplyFromCoordinator*
Arena::CreateMaybeMessage< ::coordinator_proto::ReplyFromCoordinator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::ReplyFromCoordinator >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RequestProxyIPPort*
Arena::CreateMaybeMessage< ::coordinator_proto::RequestProxyIPPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RequestProxyIPPort >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::ReplyProxyIPPort*
Arena::CreateMaybeMessage< ::coordinator_proto::ReplyProxyIPPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::ReplyProxyIPPort >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::CommitAbortKey*
Arena::CreateMaybeMessage< ::coordinator_proto::CommitAbortKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::CommitAbortKey >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::AskIfSuccess*
Arena::CreateMaybeMessage< ::coordinator_proto::AskIfSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::AskIfSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepIfSuccess*
Arena::CreateMaybeMessage< ::coordinator_proto::RepIfSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepIfSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::KeyAndClientIP*
Arena::CreateMaybeMessage< ::coordinator_proto::KeyAndClientIP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::KeyAndClientIP >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepIfGetSuccess*
Arena::CreateMaybeMessage< ::coordinator_proto::RepIfGetSuccess >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepIfGetSuccess >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::KeyFromClient*
Arena::CreateMaybeMessage< ::coordinator_proto::KeyFromClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::KeyFromClient >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::StripeIdFromClient*
Arena::CreateMaybeMessage< ::coordinator_proto::StripeIdFromClient >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::StripeIdFromClient >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepIfDeling*
Arena::CreateMaybeMessage< ::coordinator_proto::RepIfDeling >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepIfDeling >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::NumberOfStripesToMerge*
Arena::CreateMaybeMessage< ::coordinator_proto::NumberOfStripesToMerge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::NumberOfStripesToMerge >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepIfMerged*
Arena::CreateMaybeMessage< ::coordinator_proto::RepIfMerged >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepIfMerged >(arena);
}
template<> PROTOBUF_NOINLINE ::coordinator_proto::RepStripeIds*
Arena::CreateMaybeMessage< ::coordinator_proto::RepStripeIds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::coordinator_proto::RepStripeIds >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
